{"ast":null,"code":"import { Util } from '../Util.js';\nimport { Factory } from '../Factory.js';\nimport { Shape } from '../Shape.js';\nimport { Path } from './Path.js';\nimport { Text, stringToArray } from './Text.js';\nimport { getNumberValidator } from '../Validators.js';\nimport { _registerNode } from '../Global.js';\nvar EMPTY_STRING = '',\n    NORMAL = 'normal';\n\nfunction _fillFunc(context) {\n  context.fillText(this.partialText, 0, 0);\n}\n\nfunction _strokeFunc(context) {\n  context.strokeText(this.partialText, 0, 0);\n}\n\nexport class TextPath extends Shape {\n  constructor(config) {\n    super(config);\n    this.dummyCanvas = Util.createCanvasElement();\n    this.dataArray = [];\n    this.dataArray = Path.parsePathData(this.attrs.data);\n    this.on('dataChange.konva', function () {\n      this.dataArray = Path.parsePathData(this.attrs.data);\n\n      this._setTextData();\n    });\n    this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva', this._setTextData);\n\n    this._setTextData();\n  }\n\n  _sceneFunc(context) {\n    context.setAttr('font', this._getContextFont());\n    context.setAttr('textBaseline', this.textBaseline());\n    context.setAttr('textAlign', 'left');\n    context.save();\n    var textDecoration = this.textDecoration();\n    var fill = this.fill();\n    var fontSize = this.fontSize();\n    var glyphInfo = this.glyphInfo;\n\n    if (textDecoration === 'underline') {\n      context.beginPath();\n    }\n\n    for (var i = 0; i < glyphInfo.length; i++) {\n      context.save();\n      var p0 = glyphInfo[i].p0;\n      context.translate(p0.x, p0.y);\n      context.rotate(glyphInfo[i].rotation);\n      this.partialText = glyphInfo[i].text;\n      context.fillStrokeShape(this);\n\n      if (textDecoration === 'underline') {\n        if (i === 0) {\n          context.moveTo(0, fontSize / 2 + 1);\n        }\n\n        context.lineTo(fontSize, fontSize / 2 + 1);\n      }\n\n      context.restore();\n    }\n\n    if (textDecoration === 'underline') {\n      context.strokeStyle = fill;\n      context.lineWidth = fontSize / 20;\n      context.stroke();\n    }\n\n    context.restore();\n  }\n\n  _hitFunc(context) {\n    context.beginPath();\n    var glyphInfo = this.glyphInfo;\n\n    if (glyphInfo.length >= 1) {\n      var p0 = glyphInfo[0].p0;\n      context.moveTo(p0.x, p0.y);\n    }\n\n    for (var i = 0; i < glyphInfo.length; i++) {\n      var p1 = glyphInfo[i].p1;\n      context.lineTo(p1.x, p1.y);\n    }\n\n    context.setAttr('lineWidth', this.fontSize());\n    context.setAttr('strokeStyle', this.colorKey);\n    context.stroke();\n  }\n\n  getTextWidth() {\n    return this.textWidth;\n  }\n\n  getTextHeight() {\n    Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n    return this.textHeight;\n  }\n\n  setText(text) {\n    return Text.prototype.setText.call(this, text);\n  }\n\n  _getContextFont() {\n    return Text.prototype._getContextFont.call(this);\n  }\n\n  _getTextSize(text) {\n    var dummyCanvas = this.dummyCanvas;\n\n    var _context = dummyCanvas.getContext('2d');\n\n    _context.save();\n\n    _context.font = this._getContextFont();\n\n    var metrics = _context.measureText(text);\n\n    _context.restore();\n\n    return {\n      width: metrics.width,\n      height: parseInt(this.attrs.fontSize, 10)\n    };\n  }\n\n  _setTextData() {\n    var that = this;\n\n    var size = this._getTextSize(this.attrs.text);\n\n    var letterSpacing = this.letterSpacing();\n    var align = this.align();\n    var kerningFunc = this.kerningFunc();\n    this.textWidth = size.width;\n    this.textHeight = size.height;\n    var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n    this.glyphInfo = [];\n    var fullPathWidth = 0;\n\n    for (var l = 0; l < that.dataArray.length; l++) {\n      if (that.dataArray[l].pathLength > 0) {\n        fullPathWidth += that.dataArray[l].pathLength;\n      }\n    }\n\n    var offset = 0;\n\n    if (align === 'center') {\n      offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n    }\n\n    if (align === 'right') {\n      offset = Math.max(0, fullPathWidth - textFullWidth);\n    }\n\n    var charArr = stringToArray(this.text());\n    var spacesNumber = this.text().split(' ').length - 1;\n    var p0, p1, pathCmd;\n    var pIndex = -1;\n    var currentT = 0;\n\n    var getNextPathSegment = function () {\n      currentT = 0;\n      var pathData = that.dataArray;\n\n      for (var j = pIndex + 1; j < pathData.length; j++) {\n        if (pathData[j].pathLength > 0) {\n          pIndex = j;\n          return pathData[j];\n        } else if (pathData[j].command === 'M') {\n          p0 = {\n            x: pathData[j].points[0],\n            y: pathData[j].points[1]\n          };\n        }\n      }\n\n      return {};\n    };\n\n    var findSegmentToFitCharacter = function (c) {\n      var glyphWidth = that._getTextSize(c).width + letterSpacing;\n\n      if (c === ' ' && align === 'justify') {\n        glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n      }\n\n      var currLen = 0;\n      var attempts = 0;\n      p1 = undefined;\n\n      while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 && attempts < 20) {\n        attempts++;\n        var cumulativePathLength = currLen;\n\n        while (pathCmd === undefined) {\n          pathCmd = getNextPathSegment();\n\n          if (pathCmd && cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n            cumulativePathLength += pathCmd.pathLength;\n            pathCmd = undefined;\n          }\n        }\n\n        if (Object.keys(pathCmd).length === 0 || p0 === undefined) {\n          return undefined;\n        }\n\n        var needNewSegment = false;\n\n        switch (pathCmd.command) {\n          case 'L':\n            if (Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n              p1 = Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n            } else {\n              pathCmd = undefined;\n            }\n\n            break;\n\n          case 'A':\n            var start = pathCmd.points[4];\n            var dTheta = pathCmd.points[5];\n            var end = pathCmd.points[4] + dTheta;\n\n            if (currentT === 0) {\n              currentT = start + 0.00000001;\n            } else if (glyphWidth > currLen) {\n              currentT += Math.PI / 180.0 * dTheta / Math.abs(dTheta);\n            } else {\n              currentT -= Math.PI / 360.0 * dTheta / Math.abs(dTheta);\n            }\n\n            if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n              currentT = end;\n              needNewSegment = true;\n            }\n\n            p1 = Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n            break;\n\n          case 'C':\n            if (currentT === 0) {\n              if (glyphWidth > pathCmd.pathLength) {\n                currentT = 0.00000001;\n              } else {\n                currentT = glyphWidth / pathCmd.pathLength;\n              }\n            } else if (glyphWidth > currLen) {\n              currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n            } else {\n              currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n            }\n\n            if (currentT > 1.0) {\n              currentT = 1.0;\n              needNewSegment = true;\n            }\n\n            p1 = Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n            break;\n\n          case 'Q':\n            if (currentT === 0) {\n              currentT = glyphWidth / pathCmd.pathLength;\n            } else if (glyphWidth > currLen) {\n              currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n            } else {\n              currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n            }\n\n            if (currentT > 1.0) {\n              currentT = 1.0;\n              needNewSegment = true;\n            }\n\n            p1 = Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n            break;\n        }\n\n        if (p1 !== undefined) {\n          currLen = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n        }\n\n        if (needNewSegment) {\n          needNewSegment = false;\n          pathCmd = undefined;\n        }\n      }\n    };\n\n    var testChar = 'C';\n    var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n    var lettersInOffset = offset / glyphWidth - 1;\n\n    for (var k = 0; k < lettersInOffset; k++) {\n      findSegmentToFitCharacter(testChar);\n\n      if (p0 === undefined || p1 === undefined) {\n        break;\n      }\n\n      p0 = p1;\n    }\n\n    for (var i = 0; i < charArr.length; i++) {\n      findSegmentToFitCharacter(charArr[i]);\n\n      if (p0 === undefined || p1 === undefined) {\n        break;\n      }\n\n      var width = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n      var kern = 0;\n\n      if (kerningFunc) {\n        try {\n          kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n        } catch (e) {\n          kern = 0;\n        }\n      }\n\n      p0.x += kern;\n      p1.x += kern;\n      this.textWidth += kern;\n      var midpoint = Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n      var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n      this.glyphInfo.push({\n        transposeX: midpoint.x,\n        transposeY: midpoint.y,\n        text: charArr[i],\n        rotation: rotation,\n        p0: p0,\n        p1: p1\n      });\n      p0 = p1;\n    }\n  }\n\n  getSelfRect() {\n    if (!this.glyphInfo.length) {\n      return {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n\n    var points = [];\n    this.glyphInfo.forEach(function (info) {\n      points.push(info.p0.x);\n      points.push(info.p0.y);\n      points.push(info.p1.x);\n      points.push(info.p1.y);\n    });\n    var minX = points[0] || 0;\n    var maxX = points[0] || 0;\n    var minY = points[1] || 0;\n    var maxY = points[1] || 0;\n    var x, y;\n\n    for (var i = 0; i < points.length / 2; i++) {\n      x = points[i * 2];\n      y = points[i * 2 + 1];\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      minY = Math.min(minY, y);\n      maxY = Math.max(maxY, y);\n    }\n\n    var fontSize = this.fontSize();\n    return {\n      x: minX - fontSize / 2,\n      y: minY - fontSize / 2,\n      width: maxX - minX + fontSize,\n      height: maxY - minY + fontSize\n    };\n  }\n\n}\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\n\n_registerNode(TextPath);\n\nFactory.addGetterSetter(TextPath, 'data');\nFactory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory.addGetterSetter(TextPath, 'fontSize', 12, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory.addGetterSetter(TextPath, 'align', 'left');\nFactory.addGetterSetter(TextPath, 'letterSpacing', 0, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory.addGetterSetter(TextPath, 'kerningFunc', null);","map":{"version":3,"names":["Util","Factory","Shape","Path","Text","stringToArray","getNumberValidator","_registerNode","EMPTY_STRING","NORMAL","_fillFunc","context","fillText","partialText","_strokeFunc","strokeText","TextPath","constructor","config","dummyCanvas","createCanvasElement","dataArray","parsePathData","attrs","data","on","_setTextData","_sceneFunc","setAttr","_getContextFont","textBaseline","save","textDecoration","fill","fontSize","glyphInfo","beginPath","i","length","p0","translate","x","y","rotate","rotation","text","fillStrokeShape","moveTo","lineTo","restore","strokeStyle","lineWidth","stroke","_hitFunc","p1","colorKey","getTextWidth","textWidth","getTextHeight","warn","textHeight","setText","prototype","call","_getTextSize","_context","getContext","font","metrics","measureText","width","height","parseInt","that","size","letterSpacing","align","kerningFunc","textFullWidth","Math","max","fullPathWidth","l","pathLength","offset","charArr","spacesNumber","split","pathCmd","pIndex","currentT","getNextPathSegment","pathData","j","command","points","findSegmentToFitCharacter","c","glyphWidth","currLen","attempts","undefined","abs","cumulativePathLength","Object","keys","needNewSegment","getLineLength","getPointOnLine","start","dTheta","end","PI","getPointOnEllipticalArc","getPointOnCubicBezier","getPointOnQuadraticBezier","testChar","lettersInOffset","k","kern","e","midpoint","atan2","push","transposeX","transposeY","getSelfRect","forEach","info","minX","maxX","minY","maxY","min","_fillFuncHit","_strokeFuncHit","className","_attrsAffectingSize","addGetterSetter"],"sources":["C:/traffic_sim/traffic-sim/sim_ui/node_modules/konva/lib/shapes/TextPath.js"],"sourcesContent":["import { Util } from '../Util.js';\nimport { Factory } from '../Factory.js';\nimport { Shape } from '../Shape.js';\nimport { Path } from './Path.js';\nimport { Text, stringToArray } from './Text.js';\nimport { getNumberValidator } from '../Validators.js';\nimport { _registerNode } from '../Global.js';\nvar EMPTY_STRING = '', NORMAL = 'normal';\nfunction _fillFunc(context) {\n    context.fillText(this.partialText, 0, 0);\n}\nfunction _strokeFunc(context) {\n    context.strokeText(this.partialText, 0, 0);\n}\nexport class TextPath extends Shape {\n    constructor(config) {\n        super(config);\n        this.dummyCanvas = Util.createCanvasElement();\n        this.dataArray = [];\n        this.dataArray = Path.parsePathData(this.attrs.data);\n        this.on('dataChange.konva', function () {\n            this.dataArray = Path.parsePathData(this.attrs.data);\n            this._setTextData();\n        });\n        this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva', this._setTextData);\n        this._setTextData();\n    }\n    _sceneFunc(context) {\n        context.setAttr('font', this._getContextFont());\n        context.setAttr('textBaseline', this.textBaseline());\n        context.setAttr('textAlign', 'left');\n        context.save();\n        var textDecoration = this.textDecoration();\n        var fill = this.fill();\n        var fontSize = this.fontSize();\n        var glyphInfo = this.glyphInfo;\n        if (textDecoration === 'underline') {\n            context.beginPath();\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            context.save();\n            var p0 = glyphInfo[i].p0;\n            context.translate(p0.x, p0.y);\n            context.rotate(glyphInfo[i].rotation);\n            this.partialText = glyphInfo[i].text;\n            context.fillStrokeShape(this);\n            if (textDecoration === 'underline') {\n                if (i === 0) {\n                    context.moveTo(0, fontSize / 2 + 1);\n                }\n                context.lineTo(fontSize, fontSize / 2 + 1);\n            }\n            context.restore();\n        }\n        if (textDecoration === 'underline') {\n            context.strokeStyle = fill;\n            context.lineWidth = fontSize / 20;\n            context.stroke();\n        }\n        context.restore();\n    }\n    _hitFunc(context) {\n        context.beginPath();\n        var glyphInfo = this.glyphInfo;\n        if (glyphInfo.length >= 1) {\n            var p0 = glyphInfo[0].p0;\n            context.moveTo(p0.x, p0.y);\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            var p1 = glyphInfo[i].p1;\n            context.lineTo(p1.x, p1.y);\n        }\n        context.setAttr('lineWidth', this.fontSize());\n        context.setAttr('strokeStyle', this.colorKey);\n        context.stroke();\n    }\n    getTextWidth() {\n        return this.textWidth;\n    }\n    getTextHeight() {\n        Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n        return this.textHeight;\n    }\n    setText(text) {\n        return Text.prototype.setText.call(this, text);\n    }\n    _getContextFont() {\n        return Text.prototype._getContextFont.call(this);\n    }\n    _getTextSize(text) {\n        var dummyCanvas = this.dummyCanvas;\n        var _context = dummyCanvas.getContext('2d');\n        _context.save();\n        _context.font = this._getContextFont();\n        var metrics = _context.measureText(text);\n        _context.restore();\n        return {\n            width: metrics.width,\n            height: parseInt(this.attrs.fontSize, 10),\n        };\n    }\n    _setTextData() {\n        var that = this;\n        var size = this._getTextSize(this.attrs.text);\n        var letterSpacing = this.letterSpacing();\n        var align = this.align();\n        var kerningFunc = this.kerningFunc();\n        this.textWidth = size.width;\n        this.textHeight = size.height;\n        var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n        this.glyphInfo = [];\n        var fullPathWidth = 0;\n        for (var l = 0; l < that.dataArray.length; l++) {\n            if (that.dataArray[l].pathLength > 0) {\n                fullPathWidth += that.dataArray[l].pathLength;\n            }\n        }\n        var offset = 0;\n        if (align === 'center') {\n            offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n        }\n        if (align === 'right') {\n            offset = Math.max(0, fullPathWidth - textFullWidth);\n        }\n        var charArr = stringToArray(this.text());\n        var spacesNumber = this.text().split(' ').length - 1;\n        var p0, p1, pathCmd;\n        var pIndex = -1;\n        var currentT = 0;\n        var getNextPathSegment = function () {\n            currentT = 0;\n            var pathData = that.dataArray;\n            for (var j = pIndex + 1; j < pathData.length; j++) {\n                if (pathData[j].pathLength > 0) {\n                    pIndex = j;\n                    return pathData[j];\n                }\n                else if (pathData[j].command === 'M') {\n                    p0 = {\n                        x: pathData[j].points[0],\n                        y: pathData[j].points[1],\n                    };\n                }\n            }\n            return {};\n        };\n        var findSegmentToFitCharacter = function (c) {\n            var glyphWidth = that._getTextSize(c).width + letterSpacing;\n            if (c === ' ' && align === 'justify') {\n                glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n            }\n            var currLen = 0;\n            var attempts = 0;\n            p1 = undefined;\n            while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&\n                attempts < 20) {\n                attempts++;\n                var cumulativePathLength = currLen;\n                while (pathCmd === undefined) {\n                    pathCmd = getNextPathSegment();\n                    if (pathCmd &&\n                        cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n                        cumulativePathLength += pathCmd.pathLength;\n                        pathCmd = undefined;\n                    }\n                }\n                if (Object.keys(pathCmd).length === 0 || p0 === undefined) {\n                    return undefined;\n                }\n                var needNewSegment = false;\n                switch (pathCmd.command) {\n                    case 'L':\n                        if (Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n                            p1 = Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n                        }\n                        else {\n                            pathCmd = undefined;\n                        }\n                        break;\n                    case 'A':\n                        var start = pathCmd.points[4];\n                        var dTheta = pathCmd.points[5];\n                        var end = pathCmd.points[4] + dTheta;\n                        if (currentT === 0) {\n                            currentT = start + 0.00000001;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += ((Math.PI / 180.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        else {\n                            currentT -= ((Math.PI / 360.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        if ((dTheta < 0 && currentT < end) ||\n                            (dTheta >= 0 && currentT > end)) {\n                            currentT = end;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n                        break;\n                    case 'C':\n                        if (currentT === 0) {\n                            if (glyphWidth > pathCmd.pathLength) {\n                                currentT = 0.00000001;\n                            }\n                            else {\n                                currentT = glyphWidth / pathCmd.pathLength;\n                            }\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n                        }\n                        else {\n                            currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n                        break;\n                    case 'Q':\n                        if (currentT === 0) {\n                            currentT = glyphWidth / pathCmd.pathLength;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n                        }\n                        else {\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n                        break;\n                }\n                if (p1 !== undefined) {\n                    currLen = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                }\n                if (needNewSegment) {\n                    needNewSegment = false;\n                    pathCmd = undefined;\n                }\n            }\n        };\n        var testChar = 'C';\n        var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n        var lettersInOffset = offset / glyphWidth - 1;\n        for (var k = 0; k < lettersInOffset; k++) {\n            findSegmentToFitCharacter(testChar);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            p0 = p1;\n        }\n        for (var i = 0; i < charArr.length; i++) {\n            findSegmentToFitCharacter(charArr[i]);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            var width = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n            var kern = 0;\n            if (kerningFunc) {\n                try {\n                    kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n                }\n                catch (e) {\n                    kern = 0;\n                }\n            }\n            p0.x += kern;\n            p1.x += kern;\n            this.textWidth += kern;\n            var midpoint = Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n            var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n            this.glyphInfo.push({\n                transposeX: midpoint.x,\n                transposeY: midpoint.y,\n                text: charArr[i],\n                rotation: rotation,\n                p0: p0,\n                p1: p1,\n            });\n            p0 = p1;\n        }\n    }\n    getSelfRect() {\n        if (!this.glyphInfo.length) {\n            return {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0,\n            };\n        }\n        var points = [];\n        this.glyphInfo.forEach(function (info) {\n            points.push(info.p0.x);\n            points.push(info.p0.y);\n            points.push(info.p1.x);\n            points.push(info.p1.y);\n        });\n        var minX = points[0] || 0;\n        var maxX = points[0] || 0;\n        var minY = points[1] || 0;\n        var maxY = points[1] || 0;\n        var x, y;\n        for (var i = 0; i < points.length / 2; i++) {\n            x = points[i * 2];\n            y = points[i * 2 + 1];\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n        }\n        var fontSize = this.fontSize();\n        return {\n            x: minX - fontSize / 2,\n            y: minY - fontSize / 2,\n            width: maxX - minX + fontSize,\n            height: maxY - minY + fontSize,\n        };\n    }\n}\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\n_registerNode(TextPath);\nFactory.addGetterSetter(TextPath, 'data');\nFactory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory.addGetterSetter(TextPath, 'fontSize', 12, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory.addGetterSetter(TextPath, 'align', 'left');\nFactory.addGetterSetter(TextPath, 'letterSpacing', 0, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory.addGetterSetter(TextPath, 'kerningFunc', null);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}