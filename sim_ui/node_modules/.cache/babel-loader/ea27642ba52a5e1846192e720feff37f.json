{"ast":null,"code":"import { Util } from './Util.js';\nimport { Factory } from './Factory.js';\nimport { Container } from './Container.js';\nimport { Konva } from './Global.js';\nimport { SceneCanvas, HitCanvas } from './Canvas.js';\nimport { DD } from './DragAndDrop.js';\nimport { _registerNode } from './Global.js';\nimport * as PointerEvents from './PointerEvents.js';\nvar STAGE = 'Stage',\n    STRING = 'string',\n    PX = 'px',\n    MOUSEOUT = 'mouseout',\n    MOUSELEAVE = 'mouseleave',\n    MOUSEOVER = 'mouseover',\n    MOUSEENTER = 'mouseenter',\n    MOUSEMOVE = 'mousemove',\n    MOUSEDOWN = 'mousedown',\n    MOUSEUP = 'mouseup',\n    POINTERMOVE = 'pointermove',\n    POINTERDOWN = 'pointerdown',\n    POINTERUP = 'pointerup',\n    POINTERCANCEL = 'pointercancel',\n    LOSTPOINTERCAPTURE = 'lostpointercapture',\n    POINTEROUT = 'pointerout',\n    POINTERLEAVE = 'pointerleave',\n    POINTEROVER = 'pointerover',\n    POINTERENTER = 'pointerenter',\n    CONTEXTMENU = 'contextmenu',\n    TOUCHSTART = 'touchstart',\n    TOUCHEND = 'touchend',\n    TOUCHMOVE = 'touchmove',\n    TOUCHCANCEL = 'touchcancel',\n    WHEEL = 'wheel',\n    MAX_LAYERS_NUMBER = 5,\n    EVENTS = [[MOUSEENTER, '_pointerenter'], [MOUSEDOWN, '_pointerdown'], [MOUSEMOVE, '_pointermove'], [MOUSEUP, '_pointerup'], [MOUSELEAVE, '_pointerleave'], [TOUCHSTART, '_pointerdown'], [TOUCHMOVE, '_pointermove'], [TOUCHEND, '_pointerup'], [TOUCHCANCEL, '_pointercancel'], [MOUSEOVER, '_pointerover'], [WHEEL, '_wheel'], [CONTEXTMENU, '_contextmenu'], [POINTERDOWN, '_pointerdown'], [POINTERMOVE, '_pointermove'], [POINTERUP, '_pointerup'], [POINTERCANCEL, '_pointercancel'], [LOSTPOINTERCAPTURE, '_lostpointercapture']];\nconst EVENTS_MAP = {\n  mouse: {\n    [POINTEROUT]: MOUSEOUT,\n    [POINTERLEAVE]: MOUSELEAVE,\n    [POINTEROVER]: MOUSEOVER,\n    [POINTERENTER]: MOUSEENTER,\n    [POINTERMOVE]: MOUSEMOVE,\n    [POINTERDOWN]: MOUSEDOWN,\n    [POINTERUP]: MOUSEUP,\n    [POINTERCANCEL]: 'mousecancel',\n    pointerclick: 'click',\n    pointerdblclick: 'dblclick'\n  },\n  touch: {\n    [POINTEROUT]: 'touchout',\n    [POINTERLEAVE]: 'touchleave',\n    [POINTEROVER]: 'touchover',\n    [POINTERENTER]: 'touchenter',\n    [POINTERMOVE]: TOUCHMOVE,\n    [POINTERDOWN]: TOUCHSTART,\n    [POINTERUP]: TOUCHEND,\n    [POINTERCANCEL]: TOUCHCANCEL,\n    pointerclick: 'tap',\n    pointerdblclick: 'dbltap'\n  },\n  pointer: {\n    [POINTEROUT]: POINTEROUT,\n    [POINTERLEAVE]: POINTERLEAVE,\n    [POINTEROVER]: POINTEROVER,\n    [POINTERENTER]: POINTERENTER,\n    [POINTERMOVE]: POINTERMOVE,\n    [POINTERDOWN]: POINTERDOWN,\n    [POINTERUP]: POINTERUP,\n    [POINTERCANCEL]: POINTERCANCEL,\n    pointerclick: 'pointerclick',\n    pointerdblclick: 'pointerdblclick'\n  }\n};\n\nconst getEventType = type => {\n  if (type.indexOf('pointer') >= 0) {\n    return 'pointer';\n  }\n\n  if (type.indexOf('touch') >= 0) {\n    return 'touch';\n  }\n\n  return 'mouse';\n};\n\nconst getEventsMap = eventType => {\n  const type = getEventType(eventType);\n\n  if (type === 'pointer') {\n    return Konva.pointerEventsEnabled && EVENTS_MAP.pointer;\n  }\n\n  if (type === 'touch') {\n    return EVENTS_MAP.touch;\n  }\n\n  if (type === 'mouse') {\n    return EVENTS_MAP.mouse;\n  }\n};\n\nfunction checkNoClip() {\n  let attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {\n    Util.warn('Stage does not support clipping. Please use clip for Layers or Groups.');\n  }\n\n  return attrs;\n}\n\nconst NO_POINTERS_MESSAGE = `Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);`;\nexport const stages = [];\nexport class Stage extends Container {\n  constructor(config) {\n    super(checkNoClip(config));\n    this._pointerPositions = [];\n    this._changedPointerPositions = [];\n\n    this._buildDOM();\n\n    this._bindContentEvents();\n\n    stages.push(this);\n    this.on('widthChange.konva heightChange.konva', this._resizeDOM);\n    this.on('visibleChange.konva', this._checkVisibility);\n    this.on('clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva', () => {\n      checkNoClip(this.attrs);\n    });\n\n    this._checkVisibility();\n  }\n\n  _validateAdd(child) {\n    const isLayer = child.getType() === 'Layer';\n    const isFastLayer = child.getType() === 'FastLayer';\n    const valid = isLayer || isFastLayer;\n\n    if (!valid) {\n      Util.throw('You may only add layers to the stage.');\n    }\n  }\n\n  _checkVisibility() {\n    if (!this.content) {\n      return;\n    }\n\n    const style = this.visible() ? '' : 'none';\n    this.content.style.display = style;\n  }\n\n  setContainer(container) {\n    if (typeof container === STRING) {\n      if (container.charAt(0) === '.') {\n        var className = container.slice(1);\n        container = document.getElementsByClassName(className)[0];\n      } else {\n        var id;\n\n        if (container.charAt(0) !== '#') {\n          id = container;\n        } else {\n          id = container.slice(1);\n        }\n\n        container = document.getElementById(id);\n      }\n\n      if (!container) {\n        throw 'Can not find container in document with id ' + id;\n      }\n    }\n\n    this._setAttr('container', container);\n\n    if (this.content) {\n      if (this.content.parentElement) {\n        this.content.parentElement.removeChild(this.content);\n      }\n\n      container.appendChild(this.content);\n    }\n\n    return this;\n  }\n\n  shouldDrawHit() {\n    return true;\n  }\n\n  clear() {\n    var layers = this.children,\n        len = layers.length,\n        n;\n\n    for (n = 0; n < len; n++) {\n      layers[n].clear();\n    }\n\n    return this;\n  }\n\n  clone(obj) {\n    if (!obj) {\n      obj = {};\n    }\n\n    obj.container = typeof document !== 'undefined' && document.createElement('div');\n    return Container.prototype.clone.call(this, obj);\n  }\n\n  destroy() {\n    super.destroy();\n    var content = this.content;\n\n    if (content && Util._isInDocument(content)) {\n      this.container().removeChild(content);\n    }\n\n    var index = stages.indexOf(this);\n\n    if (index > -1) {\n      stages.splice(index, 1);\n    }\n\n    return this;\n  }\n\n  getPointerPosition() {\n    const pos = this._pointerPositions[0] || this._changedPointerPositions[0];\n\n    if (!pos) {\n      Util.warn(NO_POINTERS_MESSAGE);\n      return null;\n    }\n\n    return {\n      x: pos.x,\n      y: pos.y\n    };\n  }\n\n  _getPointerById(id) {\n    return this._pointerPositions.find(p => p.id === id);\n  }\n\n  getPointersPositions() {\n    return this._pointerPositions;\n  }\n\n  getStage() {\n    return this;\n  }\n\n  getContent() {\n    return this.content;\n  }\n\n  _toKonvaCanvas(config) {\n    config = config || {};\n    config.x = config.x || 0;\n    config.y = config.y || 0;\n    config.width = config.width || this.width();\n    config.height = config.height || this.height();\n    var canvas = new SceneCanvas({\n      width: config.width,\n      height: config.height,\n      pixelRatio: config.pixelRatio || 1\n    });\n\n    var _context = canvas.getContext()._context;\n\n    var layers = this.children;\n\n    if (config.x || config.y) {\n      _context.translate(-1 * config.x, -1 * config.y);\n    }\n\n    layers.forEach(function (layer) {\n      if (!layer.isVisible()) {\n        return;\n      }\n\n      var layerCanvas = layer._toKonvaCanvas(config);\n\n      _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());\n    });\n    return canvas;\n  }\n\n  getIntersection(pos) {\n    if (!pos) {\n      return null;\n    }\n\n    var layers = this.children,\n        len = layers.length,\n        end = len - 1,\n        n;\n\n    for (n = end; n >= 0; n--) {\n      const shape = layers[n].getIntersection(pos);\n\n      if (shape) {\n        return shape;\n      }\n    }\n\n    return null;\n  }\n\n  _resizeDOM() {\n    var width = this.width();\n    var height = this.height();\n\n    if (this.content) {\n      this.content.style.width = width + PX;\n      this.content.style.height = height + PX;\n    }\n\n    this.bufferCanvas.setSize(width, height);\n    this.bufferHitCanvas.setSize(width, height);\n    this.children.forEach(layer => {\n      layer.setSize({\n        width,\n        height\n      });\n      layer.draw();\n    });\n  }\n\n  add(layer) {\n    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      rest[_key - 1] = arguments[_key];\n    }\n\n    if (arguments.length > 1) {\n      for (var i = 0; i < arguments.length; i++) {\n        this.add(arguments[i]);\n      }\n\n      return this;\n    }\n\n    super.add(layer);\n    var length = this.children.length;\n\n    if (length > MAX_LAYERS_NUMBER) {\n      Util.warn('The stage has ' + length + ' layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.');\n    }\n\n    layer.setSize({\n      width: this.width(),\n      height: this.height()\n    });\n    layer.draw();\n\n    if (Konva.isBrowser) {\n      this.content.appendChild(layer.canvas._canvas);\n    }\n\n    return this;\n  }\n\n  getParent() {\n    return null;\n  }\n\n  getLayer() {\n    return null;\n  }\n\n  hasPointerCapture(pointerId) {\n    return PointerEvents.hasPointerCapture(pointerId, this);\n  }\n\n  setPointerCapture(pointerId) {\n    PointerEvents.setPointerCapture(pointerId, this);\n  }\n\n  releaseCapture(pointerId) {\n    PointerEvents.releaseCapture(pointerId, this);\n  }\n\n  getLayers() {\n    return this.children;\n  }\n\n  _bindContentEvents() {\n    if (!Konva.isBrowser) {\n      return;\n    }\n\n    EVENTS.forEach(_ref => {\n      let [event, methodName] = _ref;\n      this.content.addEventListener(event, evt => {\n        this[methodName](evt);\n      });\n    });\n  }\n\n  _pointerenter(evt) {\n    this.setPointersPositions(evt);\n    const events = getEventsMap(evt.type);\n\n    this._fire(events.pointerenter, {\n      evt: evt,\n      target: this,\n      currentTarget: this\n    });\n  }\n\n  _pointerover(evt) {\n    this.setPointersPositions(evt);\n    const events = getEventsMap(evt.type);\n\n    this._fire(events.pointerover, {\n      evt: evt,\n      target: this,\n      currentTarget: this\n    });\n  }\n\n  _getTargetShape(evenType) {\n    let shape = this[evenType + 'targetShape'];\n\n    if (shape && !shape.getStage()) {\n      shape = null;\n    }\n\n    return shape;\n  }\n\n  _pointerleave(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n\n    if (!events) {\n      return;\n    }\n\n    this.setPointersPositions(evt);\n\n    var targetShape = this._getTargetShape(eventType);\n\n    var eventsEnabled = !DD.isDragging || Konva.hitOnDragEnabled;\n\n    if (targetShape && eventsEnabled) {\n      targetShape._fireAndBubble(events.pointerout, {\n        evt: evt\n      });\n\n      targetShape._fireAndBubble(events.pointerleave, {\n        evt: evt\n      });\n\n      this._fire(events.pointerleave, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n\n      this[eventType + 'targetShape'] = null;\n    } else if (eventsEnabled) {\n      this._fire(events.pointerleave, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n\n      this._fire(events.pointerout, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n    }\n\n    this.pointerPos = undefined;\n    this._pointerPositions = [];\n  }\n\n  _pointerdown(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n\n    if (!events) {\n      return;\n    }\n\n    this.setPointersPositions(evt);\n    var triggeredOnShape = false;\n\n    this._changedPointerPositions.forEach(pos => {\n      var shape = this.getIntersection(pos);\n      DD.justDragged = false;\n      Konva['_' + eventType + 'ListenClick'] = true;\n      const hasShape = shape && shape.isListening();\n\n      if (!hasShape) {\n        return;\n      }\n\n      if (Konva.capturePointerEventsEnabled) {\n        shape.setPointerCapture(pos.id);\n      }\n\n      this[eventType + 'ClickStartShape'] = shape;\n\n      shape._fireAndBubble(events.pointerdown, {\n        evt: evt,\n        pointerId: pos.id\n      });\n\n      triggeredOnShape = true;\n      const isTouch = evt.type.indexOf('touch') >= 0;\n\n      if (shape.preventDefault() && evt.cancelable && isTouch) {\n        evt.preventDefault();\n      }\n    });\n\n    if (!triggeredOnShape) {\n      this._fire(events.pointerdown, {\n        evt: evt,\n        target: this,\n        currentTarget: this,\n        pointerId: this._pointerPositions[0].id\n      });\n    }\n  }\n\n  _pointermove(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n\n    if (!events) {\n      return;\n    }\n\n    if (DD.isDragging && DD.node.preventDefault() && evt.cancelable) {\n      evt.preventDefault();\n    }\n\n    this.setPointersPositions(evt);\n    var eventsEnabled = !DD.isDragging || Konva.hitOnDragEnabled;\n\n    if (!eventsEnabled) {\n      return;\n    }\n\n    var processedShapesIds = {};\n    let triggeredOnShape = false;\n\n    var targetShape = this._getTargetShape(eventType);\n\n    this._changedPointerPositions.forEach(pos => {\n      const shape = PointerEvents.getCapturedShape(pos.id) || this.getIntersection(pos);\n      const pointerId = pos.id;\n      const event = {\n        evt: evt,\n        pointerId\n      };\n      var differentTarget = targetShape !== shape;\n\n      if (differentTarget && targetShape) {\n        targetShape._fireAndBubble(events.pointerout, Object.assign({}, event), shape);\n\n        targetShape._fireAndBubble(events.pointerleave, Object.assign({}, event), shape);\n      }\n\n      if (shape) {\n        if (processedShapesIds[shape._id]) {\n          return;\n        }\n\n        processedShapesIds[shape._id] = true;\n      }\n\n      if (shape && shape.isListening()) {\n        triggeredOnShape = true;\n\n        if (differentTarget) {\n          shape._fireAndBubble(events.pointerover, Object.assign({}, event), targetShape);\n\n          shape._fireAndBubble(events.pointerenter, Object.assign({}, event), targetShape);\n\n          this[eventType + 'targetShape'] = shape;\n        }\n\n        shape._fireAndBubble(events.pointermove, Object.assign({}, event));\n      } else {\n        if (targetShape) {\n          this._fire(events.pointerover, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n            pointerId\n          });\n\n          this[eventType + 'targetShape'] = null;\n        }\n      }\n    });\n\n    if (!triggeredOnShape) {\n      this._fire(events.pointermove, {\n        evt: evt,\n        target: this,\n        currentTarget: this,\n        pointerId: this._changedPointerPositions[0].id\n      });\n    }\n  }\n\n  _pointerup(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n\n    if (!events) {\n      return;\n    }\n\n    this.setPointersPositions(evt);\n    const clickStartShape = this[eventType + 'ClickStartShape'];\n    const clickEndShape = this[eventType + 'ClickEndShape'];\n    var processedShapesIds = {};\n    let triggeredOnShape = false;\n\n    this._changedPointerPositions.forEach(pos => {\n      const shape = PointerEvents.getCapturedShape(pos.id) || this.getIntersection(pos);\n\n      if (shape) {\n        shape.releaseCapture(pos.id);\n\n        if (processedShapesIds[shape._id]) {\n          return;\n        }\n\n        processedShapesIds[shape._id] = true;\n      }\n\n      const pointerId = pos.id;\n      const event = {\n        evt: evt,\n        pointerId\n      };\n      let fireDblClick = false;\n\n      if (Konva['_' + eventType + 'InDblClickWindow']) {\n        fireDblClick = true;\n        clearTimeout(this[eventType + 'DblTimeout']);\n      } else if (!DD.justDragged) {\n        Konva['_' + eventType + 'InDblClickWindow'] = true;\n        clearTimeout(this[eventType + 'DblTimeout']);\n      }\n\n      this[eventType + 'DblTimeout'] = setTimeout(function () {\n        Konva['_' + eventType + 'InDblClickWindow'] = false;\n      }, Konva.dblClickWindow);\n\n      if (shape && shape.isListening()) {\n        triggeredOnShape = true;\n        this[eventType + 'ClickEndShape'] = shape;\n\n        shape._fireAndBubble(events.pointerup, Object.assign({}, event));\n\n        if (Konva['_' + eventType + 'ListenClick'] && clickStartShape && clickStartShape === shape) {\n          shape._fireAndBubble(events.pointerclick, Object.assign({}, event));\n\n          if (fireDblClick && clickEndShape && clickEndShape === shape) {\n            shape._fireAndBubble(events.pointerdblclick, Object.assign({}, event));\n          }\n        }\n      } else {\n        this[eventType + 'ClickEndShape'] = null;\n\n        if (Konva['_' + eventType + 'ListenClick']) {\n          this._fire(events.pointerclick, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n            pointerId\n          });\n        }\n\n        if (fireDblClick) {\n          this._fire(events.pointerdblclick, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n            pointerId\n          });\n        }\n      }\n    });\n\n    if (!triggeredOnShape) {\n      this._fire(events.pointerup, {\n        evt: evt,\n        target: this,\n        currentTarget: this,\n        pointerId: this._changedPointerPositions[0].id\n      });\n    }\n\n    Konva['_' + eventType + 'ListenClick'] = false;\n\n    if (evt.cancelable && eventType !== 'touch') {\n      evt.preventDefault();\n    }\n  }\n\n  _contextmenu(evt) {\n    this.setPointersPositions(evt);\n    var shape = this.getIntersection(this.getPointerPosition());\n\n    if (shape && shape.isListening()) {\n      shape._fireAndBubble(CONTEXTMENU, {\n        evt: evt\n      });\n    } else {\n      this._fire(CONTEXTMENU, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n    }\n  }\n\n  _wheel(evt) {\n    this.setPointersPositions(evt);\n    var shape = this.getIntersection(this.getPointerPosition());\n\n    if (shape && shape.isListening()) {\n      shape._fireAndBubble(WHEEL, {\n        evt: evt\n      });\n    } else {\n      this._fire(WHEEL, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n    }\n  }\n\n  _pointercancel(evt) {\n    this.setPointersPositions(evt);\n    const shape = PointerEvents.getCapturedShape(evt.pointerId) || this.getIntersection(this.getPointerPosition());\n\n    if (shape) {\n      shape._fireAndBubble(POINTERUP, PointerEvents.createEvent(evt));\n    }\n\n    PointerEvents.releaseCapture(evt.pointerId);\n  }\n\n  _lostpointercapture(evt) {\n    PointerEvents.releaseCapture(evt.pointerId);\n  }\n\n  setPointersPositions(evt) {\n    var contentPosition = this._getContentPosition(),\n        x = null,\n        y = null;\n\n    evt = evt ? evt : window.event;\n\n    if (evt.touches !== undefined) {\n      this._pointerPositions = [];\n      this._changedPointerPositions = [];\n      Array.prototype.forEach.call(evt.touches, touch => {\n        this._pointerPositions.push({\n          id: touch.identifier,\n          x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n          y: (touch.clientY - contentPosition.top) / contentPosition.scaleY\n        });\n      });\n      Array.prototype.forEach.call(evt.changedTouches || evt.touches, touch => {\n        this._changedPointerPositions.push({\n          id: touch.identifier,\n          x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n          y: (touch.clientY - contentPosition.top) / contentPosition.scaleY\n        });\n      });\n    } else {\n      x = (evt.clientX - contentPosition.left) / contentPosition.scaleX;\n      y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;\n      this.pointerPos = {\n        x: x,\n        y: y\n      };\n      this._pointerPositions = [{\n        x,\n        y,\n        id: Util._getFirstPointerId(evt)\n      }];\n      this._changedPointerPositions = [{\n        x,\n        y,\n        id: Util._getFirstPointerId(evt)\n      }];\n    }\n  }\n\n  _setPointerPosition(evt) {\n    Util.warn('Method _setPointerPosition is deprecated. Use \"stage.setPointersPositions(event)\" instead.');\n    this.setPointersPositions(evt);\n  }\n\n  _getContentPosition() {\n    if (!this.content || !this.content.getBoundingClientRect) {\n      return {\n        top: 0,\n        left: 0,\n        scaleX: 1,\n        scaleY: 1\n      };\n    }\n\n    var rect = this.content.getBoundingClientRect();\n    return {\n      top: rect.top,\n      left: rect.left,\n      scaleX: rect.width / this.content.clientWidth || 1,\n      scaleY: rect.height / this.content.clientHeight || 1\n    };\n  }\n\n  _buildDOM() {\n    this.bufferCanvas = new SceneCanvas({\n      width: this.width(),\n      height: this.height()\n    });\n    this.bufferHitCanvas = new HitCanvas({\n      pixelRatio: 1,\n      width: this.width(),\n      height: this.height()\n    });\n\n    if (!Konva.isBrowser) {\n      return;\n    }\n\n    var container = this.container();\n\n    if (!container) {\n      throw 'Stage has no container. A container is required.';\n    }\n\n    container.innerHTML = '';\n    this.content = document.createElement('div');\n    this.content.style.position = 'relative';\n    this.content.style.userSelect = 'none';\n    this.content.className = 'konvajs-content';\n    this.content.setAttribute('role', 'presentation');\n    container.appendChild(this.content);\n\n    this._resizeDOM();\n  }\n\n  cache() {\n    Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');\n    return this;\n  }\n\n  clearCache() {\n    return this;\n  }\n\n  batchDraw() {\n    this.getChildren().forEach(function (layer) {\n      layer.batchDraw();\n    });\n    return this;\n  }\n\n}\nStage.prototype.nodeType = STAGE;\n\n_registerNode(Stage);\n\nFactory.addGetterSetter(Stage, 'container');","map":{"version":3,"names":["Util","Factory","Container","Konva","SceneCanvas","HitCanvas","DD","_registerNode","PointerEvents","STAGE","STRING","PX","MOUSEOUT","MOUSELEAVE","MOUSEOVER","MOUSEENTER","MOUSEMOVE","MOUSEDOWN","MOUSEUP","POINTERMOVE","POINTERDOWN","POINTERUP","POINTERCANCEL","LOSTPOINTERCAPTURE","POINTEROUT","POINTERLEAVE","POINTEROVER","POINTERENTER","CONTEXTMENU","TOUCHSTART","TOUCHEND","TOUCHMOVE","TOUCHCANCEL","WHEEL","MAX_LAYERS_NUMBER","EVENTS","EVENTS_MAP","mouse","pointerclick","pointerdblclick","touch","pointer","getEventType","type","indexOf","getEventsMap","eventType","pointerEventsEnabled","checkNoClip","attrs","clipFunc","clipWidth","clipHeight","warn","NO_POINTERS_MESSAGE","stages","Stage","constructor","config","_pointerPositions","_changedPointerPositions","_buildDOM","_bindContentEvents","push","on","_resizeDOM","_checkVisibility","_validateAdd","child","isLayer","getType","isFastLayer","valid","throw","content","style","visible","display","setContainer","container","charAt","className","slice","document","getElementsByClassName","id","getElementById","_setAttr","parentElement","removeChild","appendChild","shouldDrawHit","clear","layers","children","len","length","n","clone","obj","createElement","prototype","call","destroy","_isInDocument","index","splice","getPointerPosition","pos","x","y","_getPointerById","find","p","getPointersPositions","getStage","getContent","_toKonvaCanvas","width","height","canvas","pixelRatio","_context","getContext","translate","forEach","layer","isVisible","layerCanvas","drawImage","_canvas","getWidth","getPixelRatio","getHeight","getIntersection","end","shape","bufferCanvas","setSize","bufferHitCanvas","draw","add","rest","arguments","i","isBrowser","getParent","getLayer","hasPointerCapture","pointerId","setPointerCapture","releaseCapture","getLayers","event","methodName","addEventListener","evt","_pointerenter","setPointersPositions","events","_fire","pointerenter","target","currentTarget","_pointerover","pointerover","_getTargetShape","evenType","_pointerleave","targetShape","eventsEnabled","isDragging","hitOnDragEnabled","_fireAndBubble","pointerout","pointerleave","pointerPos","undefined","_pointerdown","triggeredOnShape","justDragged","hasShape","isListening","capturePointerEventsEnabled","pointerdown","isTouch","preventDefault","cancelable","_pointermove","node","processedShapesIds","getCapturedShape","differentTarget","Object","assign","_id","pointermove","_pointerup","clickStartShape","clickEndShape","fireDblClick","clearTimeout","setTimeout","dblClickWindow","pointerup","_contextmenu","_wheel","_pointercancel","createEvent","_lostpointercapture","contentPosition","_getContentPosition","window","touches","Array","identifier","clientX","left","scaleX","clientY","top","scaleY","changedTouches","_getFirstPointerId","_setPointerPosition","getBoundingClientRect","rect","clientWidth","clientHeight","innerHTML","position","userSelect","setAttribute","cache","clearCache","batchDraw","getChildren","nodeType","addGetterSetter"],"sources":["C:/traffic_sim/traffic-sim/sim_ui/node_modules/konva/lib/Stage.js"],"sourcesContent":["import { Util } from './Util.js';\nimport { Factory } from './Factory.js';\nimport { Container } from './Container.js';\nimport { Konva } from './Global.js';\nimport { SceneCanvas, HitCanvas } from './Canvas.js';\nimport { DD } from './DragAndDrop.js';\nimport { _registerNode } from './Global.js';\nimport * as PointerEvents from './PointerEvents.js';\nvar STAGE = 'Stage', STRING = 'string', PX = 'px', MOUSEOUT = 'mouseout', MOUSELEAVE = 'mouseleave', MOUSEOVER = 'mouseover', MOUSEENTER = 'mouseenter', MOUSEMOVE = 'mousemove', MOUSEDOWN = 'mousedown', MOUSEUP = 'mouseup', POINTERMOVE = 'pointermove', POINTERDOWN = 'pointerdown', POINTERUP = 'pointerup', POINTERCANCEL = 'pointercancel', LOSTPOINTERCAPTURE = 'lostpointercapture', POINTEROUT = 'pointerout', POINTERLEAVE = 'pointerleave', POINTEROVER = 'pointerover', POINTERENTER = 'pointerenter', CONTEXTMENU = 'contextmenu', TOUCHSTART = 'touchstart', TOUCHEND = 'touchend', TOUCHMOVE = 'touchmove', TOUCHCANCEL = 'touchcancel', WHEEL = 'wheel', MAX_LAYERS_NUMBER = 5, EVENTS = [\n    [MOUSEENTER, '_pointerenter'],\n    [MOUSEDOWN, '_pointerdown'],\n    [MOUSEMOVE, '_pointermove'],\n    [MOUSEUP, '_pointerup'],\n    [MOUSELEAVE, '_pointerleave'],\n    [TOUCHSTART, '_pointerdown'],\n    [TOUCHMOVE, '_pointermove'],\n    [TOUCHEND, '_pointerup'],\n    [TOUCHCANCEL, '_pointercancel'],\n    [MOUSEOVER, '_pointerover'],\n    [WHEEL, '_wheel'],\n    [CONTEXTMENU, '_contextmenu'],\n    [POINTERDOWN, '_pointerdown'],\n    [POINTERMOVE, '_pointermove'],\n    [POINTERUP, '_pointerup'],\n    [POINTERCANCEL, '_pointercancel'],\n    [LOSTPOINTERCAPTURE, '_lostpointercapture'],\n];\nconst EVENTS_MAP = {\n    mouse: {\n        [POINTEROUT]: MOUSEOUT,\n        [POINTERLEAVE]: MOUSELEAVE,\n        [POINTEROVER]: MOUSEOVER,\n        [POINTERENTER]: MOUSEENTER,\n        [POINTERMOVE]: MOUSEMOVE,\n        [POINTERDOWN]: MOUSEDOWN,\n        [POINTERUP]: MOUSEUP,\n        [POINTERCANCEL]: 'mousecancel',\n        pointerclick: 'click',\n        pointerdblclick: 'dblclick',\n    },\n    touch: {\n        [POINTEROUT]: 'touchout',\n        [POINTERLEAVE]: 'touchleave',\n        [POINTEROVER]: 'touchover',\n        [POINTERENTER]: 'touchenter',\n        [POINTERMOVE]: TOUCHMOVE,\n        [POINTERDOWN]: TOUCHSTART,\n        [POINTERUP]: TOUCHEND,\n        [POINTERCANCEL]: TOUCHCANCEL,\n        pointerclick: 'tap',\n        pointerdblclick: 'dbltap',\n    },\n    pointer: {\n        [POINTEROUT]: POINTEROUT,\n        [POINTERLEAVE]: POINTERLEAVE,\n        [POINTEROVER]: POINTEROVER,\n        [POINTERENTER]: POINTERENTER,\n        [POINTERMOVE]: POINTERMOVE,\n        [POINTERDOWN]: POINTERDOWN,\n        [POINTERUP]: POINTERUP,\n        [POINTERCANCEL]: POINTERCANCEL,\n        pointerclick: 'pointerclick',\n        pointerdblclick: 'pointerdblclick',\n    },\n};\nconst getEventType = (type) => {\n    if (type.indexOf('pointer') >= 0) {\n        return 'pointer';\n    }\n    if (type.indexOf('touch') >= 0) {\n        return 'touch';\n    }\n    return 'mouse';\n};\nconst getEventsMap = (eventType) => {\n    const type = getEventType(eventType);\n    if (type === 'pointer') {\n        return Konva.pointerEventsEnabled && EVENTS_MAP.pointer;\n    }\n    if (type === 'touch') {\n        return EVENTS_MAP.touch;\n    }\n    if (type === 'mouse') {\n        return EVENTS_MAP.mouse;\n    }\n};\nfunction checkNoClip(attrs = {}) {\n    if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {\n        Util.warn('Stage does not support clipping. Please use clip for Layers or Groups.');\n    }\n    return attrs;\n}\nconst NO_POINTERS_MESSAGE = `Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);`;\nexport const stages = [];\nexport class Stage extends Container {\n    constructor(config) {\n        super(checkNoClip(config));\n        this._pointerPositions = [];\n        this._changedPointerPositions = [];\n        this._buildDOM();\n        this._bindContentEvents();\n        stages.push(this);\n        this.on('widthChange.konva heightChange.konva', this._resizeDOM);\n        this.on('visibleChange.konva', this._checkVisibility);\n        this.on('clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva', () => {\n            checkNoClip(this.attrs);\n        });\n        this._checkVisibility();\n    }\n    _validateAdd(child) {\n        const isLayer = child.getType() === 'Layer';\n        const isFastLayer = child.getType() === 'FastLayer';\n        const valid = isLayer || isFastLayer;\n        if (!valid) {\n            Util.throw('You may only add layers to the stage.');\n        }\n    }\n    _checkVisibility() {\n        if (!this.content) {\n            return;\n        }\n        const style = this.visible() ? '' : 'none';\n        this.content.style.display = style;\n    }\n    setContainer(container) {\n        if (typeof container === STRING) {\n            if (container.charAt(0) === '.') {\n                var className = container.slice(1);\n                container = document.getElementsByClassName(className)[0];\n            }\n            else {\n                var id;\n                if (container.charAt(0) !== '#') {\n                    id = container;\n                }\n                else {\n                    id = container.slice(1);\n                }\n                container = document.getElementById(id);\n            }\n            if (!container) {\n                throw 'Can not find container in document with id ' + id;\n            }\n        }\n        this._setAttr('container', container);\n        if (this.content) {\n            if (this.content.parentElement) {\n                this.content.parentElement.removeChild(this.content);\n            }\n            container.appendChild(this.content);\n        }\n        return this;\n    }\n    shouldDrawHit() {\n        return true;\n    }\n    clear() {\n        var layers = this.children, len = layers.length, n;\n        for (n = 0; n < len; n++) {\n            layers[n].clear();\n        }\n        return this;\n    }\n    clone(obj) {\n        if (!obj) {\n            obj = {};\n        }\n        obj.container =\n            typeof document !== 'undefined' && document.createElement('div');\n        return Container.prototype.clone.call(this, obj);\n    }\n    destroy() {\n        super.destroy();\n        var content = this.content;\n        if (content && Util._isInDocument(content)) {\n            this.container().removeChild(content);\n        }\n        var index = stages.indexOf(this);\n        if (index > -1) {\n            stages.splice(index, 1);\n        }\n        return this;\n    }\n    getPointerPosition() {\n        const pos = this._pointerPositions[0] || this._changedPointerPositions[0];\n        if (!pos) {\n            Util.warn(NO_POINTERS_MESSAGE);\n            return null;\n        }\n        return {\n            x: pos.x,\n            y: pos.y,\n        };\n    }\n    _getPointerById(id) {\n        return this._pointerPositions.find((p) => p.id === id);\n    }\n    getPointersPositions() {\n        return this._pointerPositions;\n    }\n    getStage() {\n        return this;\n    }\n    getContent() {\n        return this.content;\n    }\n    _toKonvaCanvas(config) {\n        config = config || {};\n        config.x = config.x || 0;\n        config.y = config.y || 0;\n        config.width = config.width || this.width();\n        config.height = config.height || this.height();\n        var canvas = new SceneCanvas({\n            width: config.width,\n            height: config.height,\n            pixelRatio: config.pixelRatio || 1,\n        });\n        var _context = canvas.getContext()._context;\n        var layers = this.children;\n        if (config.x || config.y) {\n            _context.translate(-1 * config.x, -1 * config.y);\n        }\n        layers.forEach(function (layer) {\n            if (!layer.isVisible()) {\n                return;\n            }\n            var layerCanvas = layer._toKonvaCanvas(config);\n            _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());\n        });\n        return canvas;\n    }\n    getIntersection(pos) {\n        if (!pos) {\n            return null;\n        }\n        var layers = this.children, len = layers.length, end = len - 1, n;\n        for (n = end; n >= 0; n--) {\n            const shape = layers[n].getIntersection(pos);\n            if (shape) {\n                return shape;\n            }\n        }\n        return null;\n    }\n    _resizeDOM() {\n        var width = this.width();\n        var height = this.height();\n        if (this.content) {\n            this.content.style.width = width + PX;\n            this.content.style.height = height + PX;\n        }\n        this.bufferCanvas.setSize(width, height);\n        this.bufferHitCanvas.setSize(width, height);\n        this.children.forEach((layer) => {\n            layer.setSize({ width, height });\n            layer.draw();\n        });\n    }\n    add(layer, ...rest) {\n        if (arguments.length > 1) {\n            for (var i = 0; i < arguments.length; i++) {\n                this.add(arguments[i]);\n            }\n            return this;\n        }\n        super.add(layer);\n        var length = this.children.length;\n        if (length > MAX_LAYERS_NUMBER) {\n            Util.warn('The stage has ' +\n                length +\n                ' layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.');\n        }\n        layer.setSize({ width: this.width(), height: this.height() });\n        layer.draw();\n        if (Konva.isBrowser) {\n            this.content.appendChild(layer.canvas._canvas);\n        }\n        return this;\n    }\n    getParent() {\n        return null;\n    }\n    getLayer() {\n        return null;\n    }\n    hasPointerCapture(pointerId) {\n        return PointerEvents.hasPointerCapture(pointerId, this);\n    }\n    setPointerCapture(pointerId) {\n        PointerEvents.setPointerCapture(pointerId, this);\n    }\n    releaseCapture(pointerId) {\n        PointerEvents.releaseCapture(pointerId, this);\n    }\n    getLayers() {\n        return this.children;\n    }\n    _bindContentEvents() {\n        if (!Konva.isBrowser) {\n            return;\n        }\n        EVENTS.forEach(([event, methodName]) => {\n            this.content.addEventListener(event, (evt) => {\n                this[methodName](evt);\n            });\n        });\n    }\n    _pointerenter(evt) {\n        this.setPointersPositions(evt);\n        const events = getEventsMap(evt.type);\n        this._fire(events.pointerenter, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n        });\n    }\n    _pointerover(evt) {\n        this.setPointersPositions(evt);\n        const events = getEventsMap(evt.type);\n        this._fire(events.pointerover, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n        });\n    }\n    _getTargetShape(evenType) {\n        let shape = this[evenType + 'targetShape'];\n        if (shape && !shape.getStage()) {\n            shape = null;\n        }\n        return shape;\n    }\n    _pointerleave(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        this.setPointersPositions(evt);\n        var targetShape = this._getTargetShape(eventType);\n        var eventsEnabled = !DD.isDragging || Konva.hitOnDragEnabled;\n        if (targetShape && eventsEnabled) {\n            targetShape._fireAndBubble(events.pointerout, { evt: evt });\n            targetShape._fireAndBubble(events.pointerleave, { evt: evt });\n            this._fire(events.pointerleave, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n            this[eventType + 'targetShape'] = null;\n        }\n        else if (eventsEnabled) {\n            this._fire(events.pointerleave, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n            this._fire(events.pointerout, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n        }\n        this.pointerPos = undefined;\n        this._pointerPositions = [];\n    }\n    _pointerdown(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        this.setPointersPositions(evt);\n        var triggeredOnShape = false;\n        this._changedPointerPositions.forEach((pos) => {\n            var shape = this.getIntersection(pos);\n            DD.justDragged = false;\n            Konva['_' + eventType + 'ListenClick'] = true;\n            const hasShape = shape && shape.isListening();\n            if (!hasShape) {\n                return;\n            }\n            if (Konva.capturePointerEventsEnabled) {\n                shape.setPointerCapture(pos.id);\n            }\n            this[eventType + 'ClickStartShape'] = shape;\n            shape._fireAndBubble(events.pointerdown, {\n                evt: evt,\n                pointerId: pos.id,\n            });\n            triggeredOnShape = true;\n            const isTouch = evt.type.indexOf('touch') >= 0;\n            if (shape.preventDefault() && evt.cancelable && isTouch) {\n                evt.preventDefault();\n            }\n        });\n        if (!triggeredOnShape) {\n            this._fire(events.pointerdown, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n                pointerId: this._pointerPositions[0].id,\n            });\n        }\n    }\n    _pointermove(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        if (DD.isDragging && DD.node.preventDefault() && evt.cancelable) {\n            evt.preventDefault();\n        }\n        this.setPointersPositions(evt);\n        var eventsEnabled = !DD.isDragging || Konva.hitOnDragEnabled;\n        if (!eventsEnabled) {\n            return;\n        }\n        var processedShapesIds = {};\n        let triggeredOnShape = false;\n        var targetShape = this._getTargetShape(eventType);\n        this._changedPointerPositions.forEach((pos) => {\n            const shape = (PointerEvents.getCapturedShape(pos.id) ||\n                this.getIntersection(pos));\n            const pointerId = pos.id;\n            const event = { evt: evt, pointerId };\n            var differentTarget = targetShape !== shape;\n            if (differentTarget && targetShape) {\n                targetShape._fireAndBubble(events.pointerout, Object.assign({}, event), shape);\n                targetShape._fireAndBubble(events.pointerleave, Object.assign({}, event), shape);\n            }\n            if (shape) {\n                if (processedShapesIds[shape._id]) {\n                    return;\n                }\n                processedShapesIds[shape._id] = true;\n            }\n            if (shape && shape.isListening()) {\n                triggeredOnShape = true;\n                if (differentTarget) {\n                    shape._fireAndBubble(events.pointerover, Object.assign({}, event), targetShape);\n                    shape._fireAndBubble(events.pointerenter, Object.assign({}, event), targetShape);\n                    this[eventType + 'targetShape'] = shape;\n                }\n                shape._fireAndBubble(events.pointermove, Object.assign({}, event));\n            }\n            else {\n                if (targetShape) {\n                    this._fire(events.pointerover, {\n                        evt: evt,\n                        target: this,\n                        currentTarget: this,\n                        pointerId,\n                    });\n                    this[eventType + 'targetShape'] = null;\n                }\n            }\n        });\n        if (!triggeredOnShape) {\n            this._fire(events.pointermove, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n                pointerId: this._changedPointerPositions[0].id,\n            });\n        }\n    }\n    _pointerup(evt) {\n        const events = getEventsMap(evt.type);\n        const eventType = getEventType(evt.type);\n        if (!events) {\n            return;\n        }\n        this.setPointersPositions(evt);\n        const clickStartShape = this[eventType + 'ClickStartShape'];\n        const clickEndShape = this[eventType + 'ClickEndShape'];\n        var processedShapesIds = {};\n        let triggeredOnShape = false;\n        this._changedPointerPositions.forEach((pos) => {\n            const shape = (PointerEvents.getCapturedShape(pos.id) ||\n                this.getIntersection(pos));\n            if (shape) {\n                shape.releaseCapture(pos.id);\n                if (processedShapesIds[shape._id]) {\n                    return;\n                }\n                processedShapesIds[shape._id] = true;\n            }\n            const pointerId = pos.id;\n            const event = { evt: evt, pointerId };\n            let fireDblClick = false;\n            if (Konva['_' + eventType + 'InDblClickWindow']) {\n                fireDblClick = true;\n                clearTimeout(this[eventType + 'DblTimeout']);\n            }\n            else if (!DD.justDragged) {\n                Konva['_' + eventType + 'InDblClickWindow'] = true;\n                clearTimeout(this[eventType + 'DblTimeout']);\n            }\n            this[eventType + 'DblTimeout'] = setTimeout(function () {\n                Konva['_' + eventType + 'InDblClickWindow'] = false;\n            }, Konva.dblClickWindow);\n            if (shape && shape.isListening()) {\n                triggeredOnShape = true;\n                this[eventType + 'ClickEndShape'] = shape;\n                shape._fireAndBubble(events.pointerup, Object.assign({}, event));\n                if (Konva['_' + eventType + 'ListenClick'] &&\n                    clickStartShape &&\n                    clickStartShape === shape) {\n                    shape._fireAndBubble(events.pointerclick, Object.assign({}, event));\n                    if (fireDblClick && clickEndShape && clickEndShape === shape) {\n                        shape._fireAndBubble(events.pointerdblclick, Object.assign({}, event));\n                    }\n                }\n            }\n            else {\n                this[eventType + 'ClickEndShape'] = null;\n                if (Konva['_' + eventType + 'ListenClick']) {\n                    this._fire(events.pointerclick, {\n                        evt: evt,\n                        target: this,\n                        currentTarget: this,\n                        pointerId,\n                    });\n                }\n                if (fireDblClick) {\n                    this._fire(events.pointerdblclick, {\n                        evt: evt,\n                        target: this,\n                        currentTarget: this,\n                        pointerId,\n                    });\n                }\n            }\n        });\n        if (!triggeredOnShape) {\n            this._fire(events.pointerup, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n                pointerId: this._changedPointerPositions[0].id,\n            });\n        }\n        Konva['_' + eventType + 'ListenClick'] = false;\n        if (evt.cancelable && eventType !== 'touch') {\n            evt.preventDefault();\n        }\n    }\n    _contextmenu(evt) {\n        this.setPointersPositions(evt);\n        var shape = this.getIntersection(this.getPointerPosition());\n        if (shape && shape.isListening()) {\n            shape._fireAndBubble(CONTEXTMENU, { evt: evt });\n        }\n        else {\n            this._fire(CONTEXTMENU, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n        }\n    }\n    _wheel(evt) {\n        this.setPointersPositions(evt);\n        var shape = this.getIntersection(this.getPointerPosition());\n        if (shape && shape.isListening()) {\n            shape._fireAndBubble(WHEEL, { evt: evt });\n        }\n        else {\n            this._fire(WHEEL, {\n                evt: evt,\n                target: this,\n                currentTarget: this,\n            });\n        }\n    }\n    _pointercancel(evt) {\n        this.setPointersPositions(evt);\n        const shape = PointerEvents.getCapturedShape(evt.pointerId) ||\n            this.getIntersection(this.getPointerPosition());\n        if (shape) {\n            shape._fireAndBubble(POINTERUP, PointerEvents.createEvent(evt));\n        }\n        PointerEvents.releaseCapture(evt.pointerId);\n    }\n    _lostpointercapture(evt) {\n        PointerEvents.releaseCapture(evt.pointerId);\n    }\n    setPointersPositions(evt) {\n        var contentPosition = this._getContentPosition(), x = null, y = null;\n        evt = evt ? evt : window.event;\n        if (evt.touches !== undefined) {\n            this._pointerPositions = [];\n            this._changedPointerPositions = [];\n            Array.prototype.forEach.call(evt.touches, (touch) => {\n                this._pointerPositions.push({\n                    id: touch.identifier,\n                    x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n                    y: (touch.clientY - contentPosition.top) / contentPosition.scaleY,\n                });\n            });\n            Array.prototype.forEach.call(evt.changedTouches || evt.touches, (touch) => {\n                this._changedPointerPositions.push({\n                    id: touch.identifier,\n                    x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n                    y: (touch.clientY - contentPosition.top) / contentPosition.scaleY,\n                });\n            });\n        }\n        else {\n            x = (evt.clientX - contentPosition.left) / contentPosition.scaleX;\n            y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;\n            this.pointerPos = {\n                x: x,\n                y: y,\n            };\n            this._pointerPositions = [{ x, y, id: Util._getFirstPointerId(evt) }];\n            this._changedPointerPositions = [\n                { x, y, id: Util._getFirstPointerId(evt) },\n            ];\n        }\n    }\n    _setPointerPosition(evt) {\n        Util.warn('Method _setPointerPosition is deprecated. Use \"stage.setPointersPositions(event)\" instead.');\n        this.setPointersPositions(evt);\n    }\n    _getContentPosition() {\n        if (!this.content || !this.content.getBoundingClientRect) {\n            return {\n                top: 0,\n                left: 0,\n                scaleX: 1,\n                scaleY: 1,\n            };\n        }\n        var rect = this.content.getBoundingClientRect();\n        return {\n            top: rect.top,\n            left: rect.left,\n            scaleX: rect.width / this.content.clientWidth || 1,\n            scaleY: rect.height / this.content.clientHeight || 1,\n        };\n    }\n    _buildDOM() {\n        this.bufferCanvas = new SceneCanvas({\n            width: this.width(),\n            height: this.height(),\n        });\n        this.bufferHitCanvas = new HitCanvas({\n            pixelRatio: 1,\n            width: this.width(),\n            height: this.height(),\n        });\n        if (!Konva.isBrowser) {\n            return;\n        }\n        var container = this.container();\n        if (!container) {\n            throw 'Stage has no container. A container is required.';\n        }\n        container.innerHTML = '';\n        this.content = document.createElement('div');\n        this.content.style.position = 'relative';\n        this.content.style.userSelect = 'none';\n        this.content.className = 'konvajs-content';\n        this.content.setAttribute('role', 'presentation');\n        container.appendChild(this.content);\n        this._resizeDOM();\n    }\n    cache() {\n        Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');\n        return this;\n    }\n    clearCache() {\n        return this;\n    }\n    batchDraw() {\n        this.getChildren().forEach(function (layer) {\n            layer.batchDraw();\n        });\n        return this;\n    }\n}\nStage.prototype.nodeType = STAGE;\n_registerNode(Stage);\nFactory.addGetterSetter(Stage, 'container');\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}